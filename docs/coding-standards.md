# 13. Coding Standards (ACCI Kotlin Coding Standards v1.0)
>
> This document is a granulated shard from the main "ACCI-EAF-Architecture.md" focusing on "Coding Standards (ACCI Kotlin Coding Standards v1.0)".

These standards, collectively referred to as the **"ACCI Kotlin Coding Standards v1.0"**, are mandatory for all code generated by AI agents and human developers for the ACCI EAF project. Deviations are not permitted unless explicitly approved and documented as an exception in this section or a linked addendum. Adherence to these standards will be enforced through code reviews and automated checks in the CI/CD pipeline where possible using tools like Ktlint and Detekt.

The primary goals of these standards are to ensure code quality, consistency, maintainability, readability, and to provide clear guidelines for efficient development.

* **Primary Language & Runtime(s):**
  * **Language:** Kotlin (Version `1.9.21` as specified in "Definitive Tech Stack Selections").
  * **Runtime:** JVM (Java `21` LTS - e.g., IBM Semeru Runtimes for Power or OpenJDK, as specified in "Definitive Tech Stack Selections").

* **Style Guide & Linter:**
  * **Official Kotlin Coding Conventions:** All Kotlin code must adhere to the official Kotlin Coding Conventions documented by JetBrains: [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html)
  * **Linter/Formatter:**
    * **Ktlint:** Ktlint will be used as the primary linter and formatter to enforce these conventions. It should be integrated into the build process (Gradle task) and ideally into the IDE.
    * **IDE Formatting:** IntelliJ IDEA\'s built-in formatter should be configured to match the official Kotlin Coding Conventions and Ktlint rules (often achieved by importing settings from `.editorconfig` if Ktlint is configured to use it).
  * **Configuration:** A shared `.editorconfig` file will be maintained at the root of the monorepo, containing settings for Ktlint and general editor configurations (indentation, line endings, etc.). Specific Ktlint rule set configurations, if deviating from defaults or adding custom rules, will be documented and managed centrally.
  * **CI Enforcement:** The CI/CD pipeline must include a step to run Ktlint checks; builds should fail if violations are detected.
  * **Static Analysis (Detekt):** Detekt will be used in addition to Ktlint for deeper static analysis, checking for code smells, complexity issues, and potential bugs. Detekt will also be integrated into the Gradle build and CI pipeline, with generated reports. Build failure can be configured for critical issues.

* **Naming Conventions:**
    (Adhering to Kotlin\'s standard conventions)
  * **Packages:** Lowercase with dot separation (e.g., `com.axians.accieaf.iam.domain`).
  * **Classes, Interfaces, Objects, Enums, Annotations, Type Aliases:** `PascalCase` (e.g., `TenantService`, `UserRepository`).
  * **Functions, Methods, Properties (non-constant), Local Variables, Parameters:** `camelCase` (e.g., `createTenant`, `userName`, `isActive`).
  * **Test Functions/Methods:** `camelCase` or descriptive sentences in backticks (e.g., `` `should create tenant when valid data is provided` ``).
  * **Constants (`const val`, top-level `val` with `@JvmField` in objects, `enum` entries):** `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`, `DEFAULT_TIMEOUT_MS`).
  * **Generic Type Parameters:** Single uppercase letter (e.g., `T`, `R`) or a descriptive `PascalCase` name if more clarity is needed (e.g., `RequestType`).
  * **Kotlin Source Files (`.kt`):**
    * If a file contains a single top-level class/object/interface, the filename must match its name with the `.kt` extension (e.g., `Tenant.kt`).
    * If a file contains multiple top-level declarations or only extension functions/properties, the filename should be descriptive of its content in `PascalCase` (e.g., `CollectionUtils.kt`).
  * **Gradle Modules:** `kebab-case` as defined in the "Project Structure" (e.g., `eaf-core`, `eaf-iam`).

* **File Structure:**
  * **General Project Structure:** Adhere strictly to the layout defined in the "Project Structure" section of this document.
  * **Package Structure within Modules:** Within each module\'s `src/main/kotlin/` and `src/test/kotlin/`, packages should be organized by feature or layer, consistent with Hexagonal Architecture principles (e.g., `com.axians.accieaf.[moduleName].domain`, `com.axians.accieaf.[moduleName].application`, `com.axians.accieaf.[moduleName].adapter.api`, `com.axians.accieaf.[moduleName].adapter.persistence`).
  * **Unit Test File Organization:**
    * **Location:** Unit test files must be located in the `src/test/kotlin/` directory of their respective module. The package structure within `src/test/kotlin/` must mirror the package structure of the code being tested in `src/main/kotlin/`.
    * **Naming Convention:** Test class files must be named after the class they are testing, appended with `Test`. For example, a class `com.axians.accieaf.iam.application.TenantService` located in `eaf-iam/src/main/kotlin/com/axians/accieaf/iam/application/TenantService.kt` will have its corresponding test class as `com.axians.accieaf.iam.application.TenantServiceTest` in `eaf-iam/src/test/kotlin/com/axians/accieaf/iam/application/TenantServiceTest.kt`.

* **Asynchronous Operations:**
  * **Kotlin Coroutines:** Kotlin Coroutines (`suspend` functions, `kotlinx.coroutines.flow.Flow`, `kotlinx.coroutines.channels.Channel`) are the preferred mechanism for managing asynchronous operations, non-blocking I/O, and concurrency.
  * **Structured Concurrency:** Code must adhere to the principles of structured concurrency. Coroutines should be launched within a `CoroutineScope` that is tied to the lifecycle of the component managing them (e.g., a Spring service, an Axon event handler). Avoid launching coroutines on `GlobalScope` unless explicitly justified and managed.
  * **Dispatchers:** Use appropriate dispatchers from `kotlinx.coroutines.Dispatchers` (`Dispatchers.IO` for blocking I/O operations that are not yet adapted for coroutines, `Dispatchers.Default` for CPU-intensive work, `Dispatchers.Unconfined` with caution). Spring MVC controllers with `suspend` functions will typically run on an appropriate dispatcher managed by Spring.
  * **Axon Framework Integration:** Leverage Axon Framework\'s support for Kotlin Coroutines (e.g., suspending command handlers, query handlers, and event handlers where provided by `axon-kotlin` extensions or through appropriate integration).
  * **Spring Integration:** Spring Framework (including Spring Boot MVC) provides excellent support for Kotlin Coroutines. `suspend` functions can be used directly in `@RestController` methods.
  * **Error Handling:** Ensure proper error handling within coroutines using `try-catch` blocks and an understanding of coroutine cancellation.
  * **Avoid Blocking:** Do not call blocking code from within a coroutine context without switching to an appropriate dispatcher (e.g., `Dispatchers.IO`).

* **Type Safety:**
  * **Leverage Kotlin\'s Type System:** Kotlin\'s strong type system, including its robust null-safety features, must be utilized to its full extent.
    * **Null-Safety:**
      * Declare types as nullable (`?`) only when `null` is a valid and meaningful value for that variable or property.
      * Avoid the non-null assertion operator (`!!`) wherever possible. Its use is strongly discouraged and requires explicit justification in a comment if deemed absolutely necessary.
      * Prefer safe calls (`?.`), the Elvis operator (`?:`), `let` with safe calls, or other idiomatic Kotlin constructs for handling nullable types.
    * **Explicit Types for Public APIs:** Publicly exposed functions, properties, and class members (i.e., those not `private` or `internal`) must have explicit type declarations for parameters and return types. This improves code clarity and maintainability, even if the type could be inferred by the compiler. For `private` or `internal` members, type inference is acceptable if it enhances readability.
  * **Policy on `Any`:** The use of `kotlin.Any` as a type for parameters, properties, or return values should be avoided. Prefer specific types or generics (`<T>`) to maintain type safety and clarity.
  * **Type Definitions (Location and Style):**
    * **Domain Objects:** Data classes, sealed classes/interfaces, and enums representing core domain concepts (Aggregates, Entities, Value Objects, Domain Events, Commands, Queries) should typically be defined within the `domain` package (or a sub-package thereof) of their respective module (e.g., `eaf-iam/src/main/kotlin/com/axians/accieaf/iam/domain/model/User.kt`).
    * **DTOs (Data Transfer Objects):** DTOs used for API request/response payloads or for transferring data between layers should be clearly defined as data classes. They are typically located in `dto` or `model` sub-packages within the relevant adapter layer (e.g., `eaf-controlplane-api/src/main/kotlin/com/axians/accieaf/controlplane/adapter/api/dto/TenantDto.kt`) or application service layer.
    * **Immutability:** Prefer immutable types (data classes with `val` properties, `List`, `Set`, `Map` over their mutable counterparts) where practical.

* **Comments & Documentation:**
  * **KDoc (Kotlin Documentation):**
    * **Mandatory for Public APIs:** All `public` and `internal` top-level declarations (classes, interfaces, objects, functions, properties) and their members (constructors, functions, properties) must have KDoc documentation.
    * **Content:** KDoc should clearly explain the purpose of the element, its parameters (`@param`), return values (`@return`), and any exceptions it might throw (`@throws`). For classes, describe their responsibility and key features.
    * **Clarity over Verbosity:** Explain the *why* behind complex logic or non-obvious design decisions, not just *what* the code does (which should be evident from well-written, self-documenting code).
    * **Avoid Redundant Comments:** Do not comment on obvious code (e.g., simple getters/setters that only get/set a field).
  * **Inline Comments:** Use inline comments (`//`) sparingly to clarify complex or tricky sections of code that cannot be made self-evident through better naming or structure.
  * **`TODO` / `FIXME` Comments:** Use standard `// TODO:` or `// FIXME:` comments to mark areas requiring future attention, known issues, or temporary workarounds. If possible, include a reference to a tracking item (e.g., JIRA ticket ID), your initials, and the date. Example: `// TODO (MAX-123, 2025-05-16): Refactor this to use the new FoobarService.`
  * **Module `README.md` Files:** Each Gradle module (e.g., `eaf-core`, `eaf-iam`) must have a `README.md` file at its root. This README should briefly explain:
    * The purpose and main responsibilities of the module.
    * Key architectural decisions or patterns specific to the module (if any).
    * How to build and test the module (if there are specific instructions beyond standard root Gradle commands).
    * Any important dependencies or setup instructions for developers working on this module.
  * **Architectural Decision Records (ADRs):** Significant architectural decisions, especially those with non-obvious trade-offs or long-term implications, should be documented using Architectural Decision Records (ADRs). ADRs should be stored in a dedicated `docs/adr/` directory in the monorepo, using a simple format (e.g., Markdown with fields like Title, Status, Context, Decision, Consequences).

* **Dependency Management:**
  * **Tool:** Gradle with Version Catalogs (typically defined in `gradle/libs.versions.toml` at the project root, and potentially referenced/managed via `build-logic`) is the single source of truth for all external library versions.
  * **Policy on Adding New Dependencies:** Adding new external dependencies (especially to core EAF modules) requires careful consideration:
    * **Justification:** The need for the dependency must be clearly articulated. Could the functionality be achieved with existing dependencies or Kotlin/Java standard library features?
    * **Alternatives Research:** Briefly document considered alternatives and why the chosen dependency is preferred.
    * **License Compatibility:** Verify the dependency\'s license is compatible with ACCI EAF\'s overall licensing strategy and distribution model. Permissive licenses like Apache 2.0, MIT, or EPL are generally preferred. GPL/LGPL dependencies require thorough review and approval due to their reciprocal nature.
    * **Security Vulnerabilities:** Check the dependency (and its transitive dependencies) for known security vulnerabilities using tools like the OWASP Dependency-Check Gradle plugin, Snyk, or GitHub Dependabot alerts.
    * **Maturity & Maintenance:** Prefer well-maintained, stable libraries from reputable sources with an active community and good documentation. Avoid deprecated or unmaintained libraries.
    * **Transitive Dependencies:** Analyze the impact of transitive dependencies introduced by the new library. Minimize unnecessary transitive dependencies.
    * **ppc64le Compatibility:** For libraries that might include native code, ensure compatibility with the ppc64le target architecture. Pure Java/Kotlin libraries are generally safe.
    * **Approval:** For core EAF modules (`eaf-*`), adding a new external dependency may require review and approval from a lead architect or technical lead.
  * **Versioning Strategy (in Version Catalog):**
    * **Pinned Versions:** Use specific, pinned versions for all dependencies. Avoid dynamic versions (e.g., `+`, `latest.release`, version ranges like `[1.0, 2.0)`) to ensure reproducible and stable builds.
    * **Regular Updates:** Plan for regular, controlled updates of dependencies to incorporate security patches and improvements. Such updates must be tested thoroughly.
  * **Dependency Scopes:** Use appropriate Gradle dependency configurations (`implementation`, `api`, `compileOnly`, `runtimeOnly`, `testImplementation`, etc.) to correctly manage compile-time and runtime classpaths and to avoid leaking transitive dependencies unnecessarily from modules\' APIs. Use `api` sparingly and only when a module intentionally exposes types from a dependency as part of its own public API.

### 13.1 Detailed Language & Framework Conventions

This subsection provides specific conventions and best practices for the primary technologies used in the ACCI EAF: Kotlin, Spring Boot, and Axon Framework. Adherence to these guidelines is mandatory.

#### 13.1.1 Kotlin Specifics

* **Immutability:**
  * **Prefer `val` over `var`:** Declare variables and properties as immutable (`val`) by default. Use `var` only when mutability is essential and clearly justified.
  * **Immutable Collections:** Use Kotlin\'s immutable collection types (`List`, `Set`, `Map` created via `listOf()`, `setOf()`, `mapOf()`) by default. For collections that need to be modified, clearly define if a mutable version (`MutableList`, etc.) is necessary or if a new immutable collection should be created from an existing one (copy-on-write).
  * **Data Classes:** Properties in `data class`es should predominantly be declared with `val`. If an object needs to be "changed", create a new instance using the `copy()` method with the modified properties.
  * **Persistent Collections:** For scenarios requiring high-performance immutable collections with efficient modification operations, consider using Kotlin\'s experimental persistent collections library (`kotlinx.collections.immutable`) after careful evaluation.

* **Functional vs. OOP Programming:**
  * **Balanced Approach:** Kotlin excels at both paradigms. Employ a balanced approach:
    * **OOP:** Use classes, interfaces, and objects to define clear entities (especially DDD Aggregates), domain services, application services, and components with well-defined responsibilities and encapsulated state.
    * **Functional:** Leverage Kotlin\'s first-class functions, lambdas, higher-order functions, extension functions, and rich collection processing API (`map`, `filter`, `fold`, `flatMap`, sequences, etc.) for data transformations, concise business logic where appropriate, and to reduce boilerplate code.
  * **Pure Functions:** Prefer pure functions (functions without side effects whose output depends only on their input) where possible, as they are easier to reason about, test, and parallelize.

* **Error Handling Specifics (Kotlin):**
  * **Exceptions:** Continue using custom exceptions as defined in the general "Error Handling Strategy".
  * **`Result<T>` Type:** For functions within the domain or application layers that can fail in a predictable and recoverable manner (not representing system-level exceptions), consider returning Kotlin\'s `kotlin.Result<T>` type or a custom sealed class hierarchy to represent success/failure outcomes explicitly. This forces callers to handle both paths. Avoid overusing this for every possible failure; exceptions are appropriate for unexpected or truly exceptional situations.
  * **`try-catch` Expressions:** Utilize Kotlin\'s `try-catch` as an expression where it improves conciseness, e.g., `val result = try { operation() } catch (e: SpecificException) { fallbackValue }`.
  * **Coroutines Error Handling:** Ensure proper error handling in coroutines, including understanding of cancellation and the difference between `supervisorScope` and `coroutineScope` for isolating failures.

* **Null Handling (Kotlin):**
  * **Embrace Null Safety:** Fully utilize Kotlin\'s built-in null-safety features. Clearly define nullability in all type signatures (parameters, return types, properties).
  * **Avoid `!!`:** The non-null assertion operator (`!!`) is strongly discouraged. Its use must be a rare exception, explicitly justified with a comment explaining why nullability is impossible at that point.
  * **Idiomatic Null Handling:** Prefer safe calls (`?.`), the Elvis operator (`?:`), safe casts (`as?`), and scope functions (`let`, `run`, `also`, `apply`) with safe calls for handling nullable values gracefully.

* **Visibility Modifiers:**
  * Use Kotlin\'s visibility modifiers (`public`, `internal`, `protected`, `private`) diligently to encapsulate implementation details and expose clear APIs for modules and classes.
  * **`internal`:** This modifier is particularly useful for declarations that should be accessible anywhere within the same Gradle module but not from other modules, aiding in modular design.
  * Default visibility is `public`; be explicit if a more restrictive visibility is intended.

* **Logging Specifics (Kotlin):**
  * **Logger Instantiation:** Obtain an SLF4J logger instance using: `private val logger = LoggerFactory.getLogger(YourClass::class.java)` or `private val logger = LoggerFactory.getLogger(javaClass)` within a class.
  * **Parameterized Logging:** Always use parameterized logging for SLF4J (e.g., `logger.info("User {} processed action {} with result: {}", userId, action, result)`) instead of string concatenation to improve performance and readability.
  * **MDC (Mapped Diagnostic Context):** Ensure crucial contextual information (Correlation ID, Tenant ID, User ID - if safe) is placed into the MDC at the beginning of a request or operation so that it\'s automatically included in structured JSON log output by Logback.

#### 13.1.2 Spring Boot Specifics

* **Dependency Injection:**
  * **Constructor Injection:** Exclusively use constructor-based dependency injection for all Spring components (`@Service`, `@Component`, `@RestController`, `@Repository`, `@Configuration`). This promotes immutability for dependencies and makes components easier to test. Field injection (`@Autowired` on fields) is disallowed.
* **Configuration:**
  * **`@ConfigurationProperties`:** Use type-safe configuration properties by defining Kotlin `data class`es annotated with `@ConfigurationProperties` and `@Configuration`) to bind values from `application.yml` or environment variables. Avoid using `@Value` for individual properties where a group of related properties can be managed by a configuration properties class.
  * **Externalized Configuration:** Follow Spring Boot\'s conventions for externalized configuration, allowing properties to be overridden by profiles, environment variables, or command-line arguments.
* **Stereotype Annotations:**
  * Consistently use Spring\'s stereotype annotations (`@Service` for business logic, `@Component` for generic components, `@Repository` for data access layers (if not using Axon repositories exclusively), `@RestController` for API endpoints, `@Configuration` for configuration classes).
* **Transactions (`@Transactional`):**
  * Apply `@Transactional` (from `org.springframework.transaction.annotation`) to service methods that perform database operations requiring transactional consistency (e.g., read model updates, saving configuration data).
  * Understand and correctly use transaction propagation levels (e.g., `REQUIRED`, `REQUIRES_NEW`) and the `readOnly` flag where appropriate.
  * For Axon-managed aggregates, transactions are typically handled by Axon around command processing and event persistence. `@Transactional` might be more relevant for event handlers updating separate read models or for services that don\'t directly involve Axon aggregates.
* **Spring Security:**
  * Adhere to Spring Security best practices for configuring authentication (e.g., integration with `eaf-iam` for OIDC/SAML/LDAP) and authorization.
  * Utilize method security (`@PreAuthorize`, `@PostAuthorize`, `@Secured`) for fine-grained access control on service methods where appropriate, based on roles and permissions defined in `eaf-iam`.
* **REST Controllers (`@RestController`):**
  * Strive to return `ResponseEntity<T>` from controller methods to have full control over the HTTP response status, headers, and body.
  * Use appropriate HTTP verbs (GET, POST, PUT, DELETE, PATCH) semantically.
  * Implement proper request validation using Spring Validation API (Bean Validation with annotations like `@Valid`, `@NotNull`, `@Size` on DTOs).
  * Use Kotlin `suspend` functions in controllers for non-blocking request handling when I/O operations are involved in the backend.

#### 13.1.3 Axon Framework Specifics

* **Aggregates (`@Aggregate`):**
  * **Granularity:** Design aggregates to be small and focused on a single consistency boundary. An aggregate should encapsulate state and business logic that must be atomically consistent.
  * **State Modification:** Aggregate state must *only* be modified by methods annotated with `@EventSourcingHandler`, reacting to events applied by the aggregate itself.
  * **Command Handlers (`@CommandHandler`):** These methods validate incoming commands against the aggregate\'s current state and business rules. If valid, they apply one or more domain events using `AggregateLifecycle.apply(event)`. Command handlers should be lean and focused on decision-making.
  * **Identifiers:** Use `@AggregateIdentifier` correctly.
  * **Immutability:** Strive for immutable state within aggregates where possible (using `val` properties updated via event sourcing handlers creating new state objects or using immutable collections).
* **Commands, Events, Queries:**
  * **Immutability:** These messages (Commands, Events, Queries, and their results) must be immutable. Kotlin `data class`es with `val` properties are ideal for this purpose.
  * **Naming Conventions:**
    * Commands: Imperative mood, describe the action (e.g., `CreateTenantCommand`, `ActivateLicenseCommand`).
    * Events: Past tense, describe a fact that has occurred (e.g., `TenantCreatedEvent`, `LicenseActivatedEvent`).
    * Queries: Descriptive nouns or verb phrases indicating the data being requested (e.g., `FindTenantByIdQuery`, `ListActiveUsersQuery`).
  * **Versioning:** Plan for event and query model versioning early if significant evolution is expected. Axon provides mechanisms for upcasting events.
* **Event Processors (`@EventHandler`, `@SagaEventHandler`):**
  * **Tracking Event Processors:** Use Tracking Event Processors by default for event handlers that update read models or trigger Sagas. They offer better resilience, scalability, and allow replaying events.
  * **Error Handling:** Implement robust error handling for event processors using Axon\'s `ListenerInvocationErrorHandler` and `ErrorHandler` configurations. Consider strategies like retries for transient errors and Dead-Letter Queues (DLQs) for unrecoverable errors to prevent blocking event streams.
  * **Idempotency:** Design event handlers to be idempotent, as events might be redelivered under certain failure or replay scenarios.
* **Sagas (`@Saga`):**
  * Use Sagas to manage complex business transactions that span multiple aggregates and require eventual consistency.
  * Clearly define saga start conditions (`@StartSaga` on an event handler) and end conditions (`@EndSaga`).
  * Implement compensation logic (dispatching compensating commands) to handle failures in any step of the saga, ensuring the system can be brought back to a consistent state or a defined error state.
  * Associate sagas with relevant data using `@SagaEventHandler(associationProperty = "...")`.
* **Query Handlers (`@QueryHandler`):**
  * Implement query handlers to answer queries dispatched through the `QueryGateway`. These handlers typically fetch data from read models.
  * Ensure query handlers are efficient and only retrieve the data necessary for the query.

#### 13.1.4 Key Library Usage Conventions (General Kotlin/Java)

* **Kotlin Standard Library:** Make extensive use of the Kotlin standard library\'s rich features for collection processing (e.g., `map`, `filter`, `firstOrNull`, `groupBy`), scope functions (`let`, `run`, `apply`, `also`, `with`), string manipulation, and other utilities.
* **Java Time API (`java.time.*`):** Exclusively use the Java Time API (JSR 310) for all date and time representations and manipulations. This includes `Instant` (for UTC timestamps), `LocalDate`, `LocalDateTime`, `ZonedDateTime`, `Duration`, and `Period`. Avoid using legacy `java.util.Date` and `java.util.Calendar` classes.
* **Logging Facade (SLF4J):** Always use the SLF4J API for logging. The concrete implementation (Logback) is configured via Spring Boot.

#### 13.1.5 Code Generation Anti-Patterns to Avoid (Especially for AI Agent Guidance)

* **Overly Complex Lambdas/Functional Chains:** While functional programming is encouraged, avoid excessively long or deeply nested lambda expressions or functional chains that become difficult to read and debug. Break them down into smaller, well-named functions if necessary.
* **Unjustified `lateinit` or `!!`:** Minimize the use of `lateinit` (prefer constructor injection or nullable types with proper initialization). Strictly avoid `!!` unless accompanied by a strong, commented justification (see Null Handling).
* **Ignoring Function Return Values:** Do not ignore return values from functions, especially if they indicate success/failure, or if they are pure functions returning a new state (common with immutable objects). For Axon, `CommandGateway.send(command).join()` or similar constructs that might block or throw exceptions need careful handling of their results or exceptions.
* **Generic Exception Catching (`catch (e: Exception)` or `catch (e: Throwable)`):** Avoid catching overly broad exceptions unless it\'s at a top-level error boundary and the exception is appropriately logged and re-thrown as a more specific or wrapped exception, or handled definitively. Catch specific exceptions where possible.
* **Blocking Calls in Non-Blocking Contexts:** Do not make blocking I/O calls or use `runBlocking {}` within Kotlin coroutines running on default or UI dispatchers, or within reactive streams, without explicitly shifting to a blocking-IO-appropriate dispatcher (e.g., `withContext(Dispatchers.IO)`).
* **Mutable State in Spring Components:** Strive for stateless Spring components (`@Service`, `@RestController`, `@Component`) where possible. If state is necessary, ensure it is managed correctly, especially concerning concurrency (e.g., use thread-safe constructs or appropriate scoping).
* **Hardcoding Configuration:** Avoid hardcoding configuration values (URLs, credentials, timeouts, feature flags). Use Spring Boot\'s externalized configuration mechanisms (`application.yml`, environment variables, `@ConfigurationProperties`).
* **Directly Using `entityManager` or `JdbcTemplate` in Command Side of CQRS:** In a CQRS system with Axon, the command side (Aggregates) should not directly interact with JPA EntityManagers or JdbcTemplates to modify state that is also managed by event sourcing or affects read models directly. State changes go through events; read models are updated by event handlers. Direct DB access on the command side is permissible for looking up data needed for validation if that data is not part of the aggregate\'s state and not managed via Axon queries.
