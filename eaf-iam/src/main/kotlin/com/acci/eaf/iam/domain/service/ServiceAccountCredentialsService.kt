package com.acci.eaf.iam.domain.service

import java.security.SecureRandom
import java.util.Base64
import org.springframework.stereotype.Service

interface ServiceAccountCredentialsService {
    fun generateClientId(): String
    fun generateClientSecret(): String
    fun hashClientSecret(clientSecret: String): Pair<String, String>
    fun verifyClientSecret(
        providedSecret: String,
        salt: String,
        storedHash: String,
    ): Boolean
}

@Service
class DefaultServiceAccountCredentialsService(private val passwordEncoder: org.springframework.security.crypto.password.PasswordEncoder) :
    ServiceAccountCredentialsService {

    private val secureRandom = SecureRandom()
    private val clientIdLength = 32 // bytes, results in 43-44 Base64 chars
    private val clientSecretLength = 48 // bytes, results in 64 Base64 chars
    private val saltLength = 16 // bytes

    /**
     * Generates a cryptographically strong, URL-safe client ID.
     */
    override fun generateClientId(): String {
        val bytes = ByteArray(clientIdLength)
        secureRandom.nextBytes(bytes)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes)
    }

    /**
     * Generates a cryptographically strong, URL-safe client secret.
     * This secret is intended to be displayed only once.
     */
    override fun generateClientSecret(): String {
        val bytes = ByteArray(clientSecretLength)
        secureRandom.nextBytes(bytes)
        // Using standard Base64 encoder as it's common for secrets, though URL-safe is also fine.
        return Base64.getEncoder().withoutPadding().encodeToString(bytes)
    }

    /**
     * Hashes the client secret using the configured PasswordEncoder.
     * Note: Spring Security's standard PasswordEncoder implementations like BCryptPasswordEncoder
     * typically generate their own salt and embed it within the hash.
     * This example method signature assumes a separate salt might be needed or managed externally,
     * which might be true for other hashing schemes or if DelegatingPasswordEncoder is configured
     * with an encoder that requires explicit salt management. If using BCrypt directly, salt management is internal.
     *
     * For this implementation, we assume the injected PasswordEncoder handles salt generation internally if needed.
     * The 'salt' field in ServiceAccount entity would then store the salt generated by a specific hashing algorithm
     * if it's not embedded in the hash, or it might be unused if using encoders like BCrypt.
     *
     * Given the AC requirement of a `salt` field in the entity, we will proceed as if we need to manage it,
     * even though with BCrypt (a common choice with DelegatingPasswordEncoder) it's internal.
     * A more robust solution would adapt based on the actual PasswordEncoder configured.
     * For simplicity here, we'll generate a salt and combine it with the secret before hashing, or use a PasswordEncoder that expects a salt.
     *
     * Let's simplify and assume PasswordEncoder handles its own salt (like BCryptPasswordEncoder).
     * The `salt` field in the entity would then not be directly used by this specific hashing method but could be used by others.
     * However, AC1 explicitly lists a `salt` field. This indicates a design choice.
     * We will generate a salt, and for this example, we will *not* pass it to Spring's passwordEncoder.encode,
     * as standard encoders like BCrypt generate their own. The `salt` in the DB will be stored,
     * but its role in verification depends on the *actual* chosen hashing strategy for service accounts.
     *
     * Re-evaluating: If `DelegatingPasswordEncoder` is used, it can be configured with various encoders.
     * If an encoder like `Pbkdf2PasswordEncoder` or `SCryptPasswordEncoder` is used, they might require separate salt.
     * Let's stick to the entity definition: `salt` is present. We will generate a salt and store it.
     * For hashing with Spring's PasswordEncoder, if it's BCrypt, the salt argument to `matches` is ignored.
     * If it's another type, it might be used. This is a slight ambiguity if not knowing the exact PasswordEncoder type.
     *
     * Simpler approach: Generate a salt, store it. The passwordEncoder.encode() will do its thing (BCrypt embeds salt).
     * The verification will be `passwordEncoder.matches(rawSecret, hashedSecretFromDB)`.
     * The stored `salt` field from the entity becomes somewhat redundant if BCrypt is the chosen default, but ACs are king.
     */
    override fun hashClientSecret(clientSecret: String): Pair<String, String> {
        val saltBytes = ByteArray(saltLength)
        secureRandom.nextBytes(saltBytes)
        val salt = Base64.getEncoder().encodeToString(saltBytes)
        // The salt generated here is for the `ServiceAccount.salt` field.
        // Spring Security's PasswordEncoder (like BCrypt) will internally generate its own salt and embed it in the hash.
        // So, the `salt` variable here is what we store in the DB `salt` column as per requirements.
        // The `passwordEncoder.encode()` result is what we store in `clientSecretHash`.
        val hashedSecret = passwordEncoder.encode(clientSecret)
        return Pair(hashedSecret, salt) // Return the hash and the separately generated salt
    }

    /**
     * Verifies the provided client secret against the stored salt and hash.
     * The provided `salt` parameter is from the ServiceAccount entity.
     * Its usage depends on the PasswordEncoder. For BCrypt, it's not used in `matches` as salt is embedded in the hash.
     */
    override fun verifyClientSecret(
        providedSecret: String,
        salt: String,
        storedHash: String,
    ): Boolean {
        // The `salt` parameter might be unused here if the passwordEncoder is BCrypt, as it extracts salt from storedHash.
        // However, it's passed to adhere to the interface and entity structure.
        return passwordEncoder.matches(providedSecret, storedHash)
    }
}
