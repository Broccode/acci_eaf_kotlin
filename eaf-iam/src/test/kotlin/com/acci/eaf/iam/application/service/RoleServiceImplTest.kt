package com.acci.eaf.iam.application.service

import com.acci.eaf.iam.adapter.persistence.PermissionRepository
import com.acci.eaf.iam.adapter.persistence.RoleRepository
import com.acci.eaf.iam.adapter.persistence.UserRepository
import com.acci.eaf.iam.application.port.api.CreateRoleCommand
import com.acci.eaf.iam.application.port.api.RoleDto
import com.acci.eaf.iam.application.port.api.UpdateRoleCommand
import com.acci.eaf.iam.audit.AuditService
import com.acci.eaf.iam.domain.exception.PermissionNotFoundException
import com.acci.eaf.iam.domain.exception.RoleAlreadyExistsException
import com.acci.eaf.iam.domain.exception.RoleNotFoundException
import com.acci.eaf.iam.domain.model.Permission
import com.acci.eaf.iam.domain.model.Role
import io.mockk.every
import io.mockk.impl.annotations.MockK
import io.mockk.junit5.MockKExtension
import io.mockk.justRun
import io.mockk.mockk
import io.mockk.slot
import io.mockk.verify as mockkVerify
import java.util.Optional // Specific import for Optional
import java.util.UUID // Specific import for UUID
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith
import kotlin.test.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.Pageable

@ExtendWith(MockKExtension::class)
class RoleServiceImplTest {

    @MockK
    private lateinit var roleRepository: RoleRepository

    @MockK
    private lateinit var permissionRepository: PermissionRepository

    @MockK
    private lateinit var userRepository: UserRepository

    @MockK
    private lateinit var auditService: AuditService

    private lateinit var roleService: RoleServiceImpl

    private val tenantId = UUID.randomUUID()
    private val roleId = UUID.randomUUID()
    private val permissionId = UUID.randomUUID()

    private val roleSlot = slot<Role>()

    @BeforeEach
    fun setUp() {
        roleService = RoleServiceImpl(
            roleRepository,
            permissionRepository,
            userRepository,
            auditService
        )
    }

    @Test
    fun `createRole should create a role successfully`() {
        // Given
        val command = CreateRoleCommand(
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId
        )
        // Simulate Role entity that would be created and then saved
        val roleToSave = Role(
            name = command.name,
            description = command.description,
            tenantId = command.tenantId
            // roleId is generated by DB/JPA
        )
        val savedRoleWithId = Role( // Simulate role after save with ID
            roleId = UUID.randomUUID(),
            name = command.name,
            description = command.description,
            tenantId = command.tenantId
        )
        val expectedDto = RoleDto.fromEntity(savedRoleWithId)

        every { roleRepository.existsByNameAndTenantId(command.name, command.tenantId) } returns false
        every { roleRepository.save(io.mockk.any<Role>()) } returns savedRoleWithId

        // When
        val result = roleService.createRole(command)

        // Then
        assertEquals(expectedDto, result)
        mockkVerify { roleRepository.existsByNameAndTenantId(command.name, command.tenantId) }
        mockkVerify { roleRepository.save(capture(roleSlot)) }
        assertEquals(command.name, roleSlot.captured.name)
        mockkVerify { auditService.logRoleCreated(io.mockk.eq(savedRoleWithId)) }
    }

    @Test
    fun `createRole should throw exception if role with same name exists in tenant`() {
        // Given
        val command = CreateRoleCommand(
            name = "Test Role",
            description = "New Role",
            tenantId = tenantId
        )

        every { roleRepository.existsByNameAndTenantId(command.name, command.tenantId) } returns true

        // When/Then
        assertFailsWith<RoleAlreadyExistsException> {
            roleService.createRole(command)
        }

        mockkVerify { roleRepository.existsByNameAndTenantId(command.name, command.tenantId) }
        mockkVerify(exactly = 0) { roleRepository.save(io.mockk.any<Role>()) }
    }

    @Test
    fun `getRoleById should return role DTO when it exists`() {
        // Given
        val role = Role(
            roleId = roleId,
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId
        )
        val expectedDto = RoleDto.fromEntity(role)

        every { roleRepository.findById(roleId) } returns Optional.of(role)

        // When
        val result = roleService.getRoleById(roleId)

        // Then
        assertEquals(expectedDto, result)
    }

    @Test
    fun `getRoleById should throw exception when role does not exist`() {
        // Given
        every { roleRepository.findById(roleId) } returns Optional.empty()

        // When/Then
        assertFailsWith<RoleNotFoundException> {
            roleService.getRoleById(roleId)
        }
    }

    @Test
    fun `updateRole should update role successfully`() {
        // Given
        val existingRole = Role(
            roleId = roleId,
            name = "Original Name",
            description = "Original Description",
            tenantId = tenantId
        )
        val command = UpdateRoleCommand(
            roleId = roleId,
            name = "Updated Name",
            description = "Updated Description"
        )
        // Simulate entity after update
        val updatedRoleEntity = Role(
            roleId = existingRole.roleId,
            name = command.name,
            description = command.description,
            tenantId = existingRole.tenantId,
            permissions = existingRole.permissions // Ensure permissions are carried over
        )
        val expectedDto = RoleDto.fromEntity(updatedRoleEntity)

        every { roleRepository.findById(roleId) } returns Optional.of(existingRole)
        every { roleRepository.existsByNameAndTenantId(command.name, existingRole.tenantId) } returns false
        every { roleRepository.save(io.mockk.any<Role>()) } returns updatedRoleEntity

        // When
        val result = roleService.updateRole(command)

        // Then
        assertEquals(expectedDto, result)
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { roleRepository.existsByNameAndTenantId(command.name, existingRole.tenantId) }
        mockkVerify { roleRepository.save(capture(roleSlot)) }
        val capturedRole = roleSlot.captured
        assertEquals(command.name, capturedRole.name)
        assertEquals(command.description, capturedRole.description)
        mockkVerify { auditService.logRoleUpdated(io.mockk.eq(updatedRoleEntity), io.mockk.eq(existingRole.name)) }
    }

    @Test
    fun `updateRole should throw exception when role with new name already exists`() {
        // Given
        val existingRole = Role(
            roleId = roleId,
            name = "Original Name",
            description = "Original Description",
            tenantId = tenantId
        )
        val command = UpdateRoleCommand(
            roleId = roleId,
            name = "Updated Name", // This name already exists
            description = "Updated Description"
        )

        every { roleRepository.findById(roleId) } returns Optional.of(existingRole)
        every { roleRepository.existsByNameAndTenantId(command.name, existingRole.tenantId) } returns true

        // When/Then
        assertFailsWith<RoleAlreadyExistsException> {
            roleService.updateRole(command)
        }
    }

    @Test
    fun `deleteRole should delete role successfully`() {
        // Given
        val role = Role(
            roleId = roleId,
            name = "Role To Delete",
            description = "Will be deleted",
            tenantId = tenantId
        )

        every { roleRepository.findById(roleId) } returns Optional.of(role)
        justRun { roleRepository.delete(io.mockk.any<Role>()) }

        // When
        roleService.deleteRole(roleId)

        // Then
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { roleRepository.delete(io.mockk.eq(role)) }
        mockkVerify { auditService.logRoleDeleted(io.mockk.eq(role)) }
    }

    @Test
    fun `getRolesByTenant should return role DTOs for tenant`() {
        // Given
        val roles = listOf(
            Role(
                roleId = UUID.randomUUID(),
                name = "Tenant Role 1",
                description = "First tenant role",
                tenantId = tenantId
            ),
            Role(
                roleId = UUID.randomUUID(),
                name = "Tenant Role 2",
                description = "Second tenant role",
                tenantId = tenantId
            )
        )
        val expectedDtos = roles.map { RoleDto.fromEntity(it) }

        val pageable = mockk<Pageable>()
        val page = PageImpl(roles)
        val expectedPageDto = PageImpl(expectedDtos, pageable, roles.size.toLong())

        every { roleRepository.findByTenantId(tenantId, pageable) } returns page

        // When
        val result = roleService.getRolesByTenant(tenantId, pageable)

        // Then
        assertEquals(expectedPageDto.content, result.content)
        assertEquals(expectedPageDto.totalPages, result.totalPages)
        assertEquals(expectedPageDto.totalElements, result.totalElements)
    }

    @Test
    fun `addPermissionToRole should add permission successfully`() {
        // Given
        val role = Role(
            roleId = roleId,
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId,
            permissions = mutableSetOf() // Start with no permissions
        )

        val permission = Permission(
            permissionId = permissionId,
            name = "test:permission",
            description = "Test Permission"
        )

        // Simulate the role after permission is added and saved
        val roleWithPermission = Role(
            roleId = role.roleId,
            name = role.name,
            description = role.description,
            tenantId = role.tenantId,
            permissions = mutableSetOf(permission) // Now contains the permission
        )
        val expectedDto = RoleDto.fromEntity(roleWithPermission)

        every { roleRepository.findById(roleId) } returns Optional.of(role)
        every { permissionRepository.findById(permissionId) } returns Optional.of(permission)
        every { roleRepository.save(io.mockk.any<Role>()) } returns roleWithPermission

        // When
        val result = roleService.addPermissionToRole(roleId, permissionId)

        // Then
        assertEquals(expectedDto, result)
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { permissionRepository.findById(permissionId) }
        mockkVerify { roleRepository.save(capture(roleSlot)) }
        val capturedRole = roleSlot.captured
        assertTrue(capturedRole.permissions.contains(permission))
        mockkVerify { auditService.logPermissionAddedToRole(io.mockk.eq(roleWithPermission), io.mockk.eq(permission)) }
    }

    @Test
    fun `removePermissionFromRole should remove permission successfully`() {
        // Given
        val permission = Permission(
            permissionId = permissionId,
            name = "test:permission",
            description = "Test Permission"
        )

        val roleWithPermission = Role(
            roleId = roleId,
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId,
            permissions = mutableSetOf(permission)
        )

        // Simulate the role after permission is removed and saved
        val roleWithoutPermission = Role(
            roleId = roleWithPermission.roleId,
            name = roleWithPermission.name,
            description = roleWithPermission.description,
            tenantId = roleWithPermission.tenantId,
            permissions = mutableSetOf() // Now empty
        )
        val expectedDto = RoleDto.fromEntity(roleWithoutPermission)

        every { roleRepository.findById(roleId) } returns Optional.of(roleWithPermission)
        every { permissionRepository.findById(permissionId) } returns Optional.of(permission)
        every { roleRepository.save(io.mockk.any<Role>()) } returns roleWithoutPermission

        // When
        val result = roleService.removePermissionFromRole(roleId, permissionId)

        // Then
        assertEquals(expectedDto, result)
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { permissionRepository.findById(permissionId) }
        mockkVerify { roleRepository.save(capture(roleSlot)) }
        val capturedRole = roleSlot.captured
        assertTrue(!capturedRole.permissions.contains(permission))
        mockkVerify { auditService.logPermissionRemovedFromRole(io.mockk.eq(permission), io.mockk.eq(roleWithPermission)) }
    }

    @Test
    fun `addPermissionToRole should throw RoleNotFoundException when role does not exist`() {
        // Given
        every { roleRepository.findById(roleId) } returns Optional.empty()

        // When/Then
        assertFailsWith<RoleNotFoundException> {
            roleService.addPermissionToRole(roleId, permissionId)
        }
        mockkVerify(exactly = 0) { permissionRepository.findById(io.mockk.any<UUID>()) }
        mockkVerify(exactly = 0) { roleRepository.save(io.mockk.any<Role>()) }
    }

    @Test
    fun `addPermissionToRole should throw PermissionNotFoundException when permission does not exist`() {
        // Given
        val role = Role(
            roleId = roleId,
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId,
            permissions = mutableSetOf()
        )
        every { roleRepository.findById(roleId) } returns Optional.of(role)
        every { permissionRepository.findById(permissionId) } returns Optional.empty()

        // When/Then
        assertFailsWith<PermissionNotFoundException> {
            roleService.addPermissionToRole(roleId, permissionId)
        }
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { permissionRepository.findById(permissionId) }
        mockkVerify(exactly = 0) { roleRepository.save(io.mockk.any<Role>()) }
    }

    @Test
    fun `removePermissionFromRole should throw RoleNotFoundException when role does not exist`() {
        // Given
        every { roleRepository.findById(roleId) } returns Optional.empty()

        // When/Then
        assertFailsWith<RoleNotFoundException> {
            roleService.removePermissionFromRole(roleId, permissionId)
        }
        mockkVerify(exactly = 0) { permissionRepository.findById(io.mockk.any<UUID>()) }
        mockkVerify(exactly = 0) { roleRepository.save(io.mockk.any<Role>()) }
    }

    @Test
    fun `removePermissionFromRole should throw PermissionNotFoundException when permission does not exist`() {
        // Given
        val role = Role(
            roleId = roleId,
            name = "Test Role",
            description = "Test Description",
            tenantId = tenantId,
            permissions = mutableSetOf()
        )
        every { roleRepository.findById(roleId) } returns Optional.of(role)
        every { permissionRepository.findById(permissionId) } returns Optional.empty()

        // When/Then
        assertFailsWith<PermissionNotFoundException> {
            roleService.removePermissionFromRole(roleId, permissionId)
        }
        mockkVerify { roleRepository.findById(roleId) }
        mockkVerify { permissionRepository.findById(permissionId) }
        mockkVerify(exactly = 0) { roleRepository.save(io.mockk.any<Role>()) }
    }
}
